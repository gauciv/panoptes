# Webhook Signature Verification

## üìñ Overview

Panoptes signs all webhook payloads using **HMAC-SHA256** (Hash-based Message Authentication Code with SHA-256) to ensure the authenticity and integrity of webhook deliveries. This allows you to verify that webhooks truly originated from your Panoptes instance and haven't been tampered with in transit.

### What is HMAC-SHA256?

HMAC-SHA256 is a cryptographic algorithm that combines:
- **HMAC**: A method for calculating a message authentication code using a cryptographic hash function and a secret key
- **SHA-256**: A secure hashing algorithm that produces a 256-bit (32-byte) hash value

The result is a unique signature that can only be generated by someone who knows both the payload content and your secret key.

### Why Signature Verification Matters

Without signature verification, your webhook endpoint is vulnerable to:

1. **Spoofing Attacks**: Malicious actors could send fake webhooks pretending to be Panoptes
2. **Replay Attacks**: Old webhook payloads could be resent to trigger duplicate processing
3. **Man-in-the-Middle**: Intercepted webhooks could be modified before reaching your server
4. **Data Integrity**: Ensures the payload hasn't been corrupted or tampered with

**Always verify webhook signatures in production environments.**

---

## üîê How Panoptes Signs Webhooks

When Panoptes sends a webhook to your endpoint:

1. **Serializes** the payload to JSON
2. **Computes** an HMAC-SHA256 hash using your subscription's secret key
3. **Converts** the hash to a hexadecimal string (lowercase, 64 characters)
4. **Includes** the signature in the `X-Panoptes-Signature` HTTP header

Example webhook request:
```http
POST /webhook HTTP/1.1
Host: your-domain.com
Content-Type: application/json
X-Panoptes-Signature: a3f5b8c9d2e1f0a7b4c6d8e9f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0

{"event":"transaction.confirmed","data":{...}}
```

---

## ‚úÖ Verification Process

To verify a webhook signature, follow these steps:

### Step 1: Extract the Signature
Get the signature from the `X-Panoptes-Signature` header.

### Step 2: Read the Raw Request Body
Read the **exact raw bytes** of the request body. Do not parse or modify it.

### Step 3: Compute the Expected Signature
Calculate HMAC-SHA256 using:
- **Key**: Your subscription's secret key (from Panoptes dashboard)
- **Message**: The raw request body bytes
- **Output**: Hexadecimal string (lowercase)

### Step 4: Compare Securely
Compare the received signature with your computed signature using a **constant-time comparison** function to prevent timing attacks.

### Step 5: Accept or Reject
- If signatures match ‚Üí Process the webhook
- If signatures don't match ‚Üí Return 401 Unauthorized

---

## üíª Code Examples

### Node.js (Express)

```javascript
const express = require('express');
const crypto = require('crypto');

const app = express();

// IMPORTANT: Use raw body parser to preserve exact bytes
app.use(express.json({
  verify: (req, res, buf) => {
    req.rawBody = buf.toString('utf8');
  }
}));

app.post('/webhook', (req, res) => {
  const signature = req.headers['x-panoptes-signature'];
  const secret = process.env.PANOPTES_SECRET_KEY;

  if (!signature) {
    return res.status(401).json({ error: 'Missing signature' });
  }

  // Compute expected signature
  const computedSignature = crypto
    .createHmac('sha256', secret)
    .update(req.rawBody)
    .digest('hex');

  // Constant-time comparison to prevent timing attacks
  if (!crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(computedSignature)
  )) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  // Signature verified! Process the webhook
  const payload = req.body;
  console.log('Verified webhook:', payload.event);

  res.status(200).json({ success: true });
});

app.listen(3000, () => {
  console.log('Webhook server running on port 3000');
});
```

---

### Python (Flask)

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import os

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Panoptes-Signature')
    secret = os.environ.get('PANOPTES_SECRET_KEY')

    if not signature:
        return jsonify({'error': 'Missing signature'}), 401

    # Get raw request body
    raw_body = request.get_data()

    # Compute expected signature
    computed_signature = hmac.new(
        secret.encode('utf-8'),
        raw_body,
        hashlib.sha256
    ).hexdigest()

    # Constant-time comparison
    if not hmac.compare_digest(signature, computed_signature):
        return jsonify({'error': 'Invalid signature'}), 401

    # Signature verified! Process the webhook
    payload = request.get_json()
    print(f"Verified webhook: {payload.get('event')}")

    return jsonify({'success': True}), 200

if __name__ == '__main__':
    app.run(port=3000)
```

---

### C# (ASP.NET Core)

```csharp
using Microsoft.AspNetCore.Mvc;
using System.Security.Cryptography;
using System.Text;

[ApiController]
[Route("webhook")]
public class WebhookController : ControllerBase
{
    private readonly IConfiguration _configuration;

    public WebhookController(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    [HttpPost]
    public async Task<IActionResult> ReceiveWebhook()
    {
        // Extract signature from header
        if (!Request.Headers.TryGetValue("X-Panoptes-Signature", out var signature))
        {
            return Unauthorized(new { error = "Missing signature" });
        }

        // Read raw request body
        Request.EnableBuffering(); // Allow reading body multiple times
        using var reader = new StreamReader(Request.Body, Encoding.UTF8, leaveOpen: true);
        var rawBody = await reader.ReadToEndAsync();
        Request.Body.Position = 0; // Reset for model binding

        // Get secret key from configuration
        var secret = _configuration["PANOPTES_SECRET_KEY"];

        // Compute expected signature
        var computedSignature = ComputeHmacSha256(secret, rawBody);

        // Constant-time comparison
        if (!CryptographicOperations.FixedTimeEquals(
            Encoding.UTF8.GetBytes(signature),
            Encoding.UTF8.GetBytes(computedSignature)))
        {
            return Unauthorized(new { error = "Invalid signature" });
        }

        // Signature verified! Process the webhook
        var payload = await System.Text.Json.JsonSerializer.DeserializeAsync<dynamic>(
            Request.Body);

        return Ok(new { success = true });
    }

    private string ComputeHmacSha256(string secret, string payload)
    {
        var keyBytes = Encoding.UTF8.GetBytes(secret);
        var payloadBytes = Encoding.UTF8.GetBytes(payload);

        using var hmac = new HMACSHA256(keyBytes);
        var hashBytes = hmac.ComputeHash(payloadBytes);

        return Convert.ToHexString(hashBytes).ToLowerInvariant();
    }
}
```

---

### Go

```go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "crypto/subtle"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
)

type WebhookPayload struct {
    Event string          `json:"event"`
    Data  json.RawMessage `json:"data"`
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    // Extract signature
    signature := r.Header.Get("X-Panoptes-Signature")
    if signature == "" {
        http.Error(w, `{"error":"Missing signature"}`, http.StatusUnauthorized)
        return
    }

    // Read raw body
    rawBody, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, `{"error":"Failed to read body"}`, http.StatusBadRequest)
        return
    }
    defer r.Body.Close()

    // Get secret from environment
    secret := os.Getenv("PANOPTES_SECRET_KEY")

    // Compute expected signature
    computedSignature := computeHmacSha256(secret, rawBody)

    // Constant-time comparison
    if subtle.ConstantTimeCompare(
        []byte(signature),
        []byte(computedSignature),
    ) != 1 {
        http.Error(w, `{"error":"Invalid signature"}`, http.StatusUnauthorized)
        return
    }

    // Signature verified! Process the webhook
    var payload WebhookPayload
    if err := json.Unmarshal(rawBody, &payload); err != nil {
        http.Error(w, `{"error":"Invalid JSON"}`, http.StatusBadRequest)
        return
    }

    fmt.Printf("Verified webhook: %s\n", payload.Event)

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func computeHmacSha256(secret string, payload []byte) string {
    h := hmac.New(sha256.New, []byte(secret))
    h.Write(payload)
    return hex.EncodeToString(h.Sum(nil))
}

func main() {
    http.HandleFunc("/webhook", webhookHandler)
    fmt.Println("Webhook server running on :3000")
    http.ListenAndServe(":3000", nil)
}
```

---

### PHP

```php
<?php

// webhook.php

header('Content-Type: application/json');

// Extract signature
$signature = $_SERVER['HTTP_X_PANOPTES_SIGNATURE'] ?? '';

if (empty($signature)) {
    http_response_code(401);
    echo json_encode(['error' => 'Missing signature']);
    exit;
}

// Read raw request body
$rawBody = file_get_contents('php://input');

// Get secret from environment
$secret = getenv('PANOPTES_SECRET_KEY');

// Compute expected signature
$computedSignature = hash_hmac('sha256', $rawBody, $secret);

// Constant-time comparison
if (!hash_equals($computedSignature, $signature)) {
    http_response_code(401);
    echo json_encode(['error' => 'Invalid signature']);
    exit;
}

// Signature verified! Process the webhook
$payload = json_decode($rawBody, true);

if (json_last_error() !== JSON_ERROR_NONE) {
    http_response_code(400);
    echo json_encode(['error' => 'Invalid JSON']);
    exit;
}

error_log("Verified webhook: " . $payload['event']);

http_response_code(200);
echo json_encode(['success' => true]);
```

---

### Ruby (Sinatra)

```ruby
require 'sinatra'
require 'json'
require 'openssl'

post '/webhook' do
  # Extract signature
  signature = request.env['HTTP_X_PANOPTES_SIGNATURE']

  if signature.nil? || signature.empty?
    halt 401, { error: 'Missing signature' }.to_json
  end

  # Read raw request body
  request.body.rewind
  raw_body = request.body.read

  # Get secret from environment
  secret = ENV['PANOPTES_SECRET_KEY']

  # Compute expected signature
  computed_signature = OpenSSL::HMAC.hexdigest(
    OpenSSL::Digest.new('sha256'),
    secret,
    raw_body
  )

  # Constant-time comparison
  unless Rack::Utils.secure_compare(signature, computed_signature)
    halt 401, { error: 'Invalid signature' }.to_json
  end

  # Signature verified! Process the webhook
  payload = JSON.parse(raw_body)
  puts "Verified webhook: #{payload['event']}"

  content_type :json
  { success: true }.to_json
end

# Start server
set :port, 3000
puts 'Webhook server running on port 3000'
```

---

### Java (Spring Boot)

```java
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Map;

@RestController
@RequestMapping("/webhook")
public class WebhookController {

    @PostMapping
    public ResponseEntity<Map<String, Object>> receiveWebhook(
            @RequestHeader(value = "X-Panoptes-Signature", required = false) String signature,
            @RequestBody String rawBody) {

        // Check signature presence
        if (signature == null || signature.isEmpty()) {
            return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(Map.of("error", "Missing signature"));
        }

        // Get secret from environment
        String secret = System.getenv("PANOPTES_SECRET_KEY");

        try {
            // Compute expected signature
            String computedSignature = computeHmacSha256(secret, rawBody);

            // Constant-time comparison
            if (!MessageDigest.isEqual(
                signature.getBytes(StandardCharsets.UTF_8),
                computedSignature.getBytes(StandardCharsets.UTF_8))) {
                return ResponseEntity
                    .status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", "Invalid signature"));
            }

            // Signature verified! Process the webhook
            System.out.println("Verified webhook received");

            return ResponseEntity.ok(Map.of("success", true));

        } catch (Exception e) {
            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Verification failed"));
        }
    }

    private String computeHmacSha256(String secret, String payload) throws Exception {
        Mac sha256Hmac = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(
            secret.getBytes(StandardCharsets.UTF_8),
            "HmacSHA256"
        );
        sha256Hmac.init(secretKey);

        byte[] hash = sha256Hmac.doFinal(payload.getBytes(StandardCharsets.UTF_8));

        // Convert to hex string
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }

        return hexString.toString();
    }
}
```

---

### Rust (Actix-web)

```rust
use actix_web::{post, web, App, HttpRequest, HttpResponse, HttpServer};
use hmac::{Hmac, Mac};
use serde_json::Value;
use sha2::Sha256;
use std::env;

type HmacSha256 = Hmac<Sha256>;

#[post("/webhook")]
async fn webhook(req: HttpRequest, body: web::Bytes) -> HttpResponse {
    // Extract signature
    let signature = match req.headers().get("x-panoptes-signature") {
        Some(sig) => match sig.to_str() {
            Ok(s) => s,
            Err(_) => {
                return HttpResponse::Unauthorized().json(
                    serde_json::json!({"error": "Invalid signature header"})
                )
            }
        },
        None => {
            return HttpResponse::Unauthorized().json(
                serde_json::json!({"error": "Missing signature"})
            )
        }
    };

    // Get secret from environment
    let secret = env::var("PANOPTES_SECRET_KEY")
        .expect("PANOPTES_SECRET_KEY must be set");

    // Compute expected signature
    let computed_signature = compute_hmac_sha256(&secret, &body);

    // Constant-time comparison
    if !constant_time_compare(signature.as_bytes(), computed_signature.as_bytes()) {
        return HttpResponse::Unauthorized().json(
            serde_json::json!({"error": "Invalid signature"})
        );
    }

    // Signature verified! Process the webhook
    let payload: Value = match serde_json::from_slice(&body) {
        Ok(p) => p,
        Err(_) => {
            return HttpResponse::BadRequest().json(
                serde_json::json!({"error": "Invalid JSON"})
            )
        }
    };

    println!("Verified webhook: {}", payload["event"]);

    HttpResponse::Ok().json(serde_json::json!({"success": true}))
}

fn compute_hmac_sha256(secret: &str, payload: &[u8]) -> String {
    let mut mac = HmacSha256::new_from_slice(secret.as_bytes())
        .expect("HMAC can take key of any size");
    mac.update(payload);
    
    let result = mac.finalize();
    hex::encode(result.into_bytes())
}

fn constant_time_compare(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    
    let mut result = 0u8;
    for (x, y) in a.iter().zip(b.iter()) {
        result |= x ^ y;
    }
    result == 0
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    println!("Webhook server running on :3000");
    
    HttpServer::new(|| App::new().service(webhook))
        .bind(("127.0.0.1", 3000))?
        .run()
        .await
}
```

---

## üîß Troubleshooting

### Common Issues

#### ‚ùå Signature Always Fails

**Problem**: Your computed signature never matches the received signature.

**Solutions**:

1. **Check the raw body**: Ensure you're using the **exact raw bytes** of the request body
   ```javascript
   // ‚ùå Wrong - body already parsed
   const body = JSON.stringify(req.body);
   
   // ‚úÖ Correct - use raw body
   const body = req.rawBody;
   ```

2. **Verify encoding**: Use UTF-8 encoding consistently
   ```python
   # ‚úÖ Correct
   secret.encode('utf-8')
   ```

3. **Check hex format**: Ensure lowercase hexadecimal output
   ```csharp
   // ‚úÖ Correct
   Convert.ToHexString(hashBytes).ToLowerInvariant()
   ```

4. **Confirm secret key**: Double-check you're using the correct secret from your subscription

#### ‚ùå Intermittent Failures

**Problem**: Signature verification fails randomly.

**Solutions**:

1. **Body modification**: Ensure no middleware modifies the body before verification
   ```javascript
   // Put verification BEFORE other body parsers
   app.use(verifyWebhookSignature);
   app.use(express.json());
   ```

2. **Character encoding**: Watch for encoding issues with special characters
   ```python
   # Always use raw bytes
   raw_body = request.get_data()
   ```

#### ‚ùå Performance Issues

**Problem**: Signature verification is slow.

**Solutions**:

1. **Use native crypto libraries**: Don't implement HMAC yourself
2. **Avoid multiple body reads**: Cache the raw body once
3. **Use constant-time comparison**: Built-in functions are optimized

### Testing Your Implementation

Test with a known signature:

**Secret**: `test-secret-key`  
**Payload**: `{"event":"test","data":{"value":123}}`  
**Expected Signature**: `d3a5e8c7b2f9a1d4e6c8b0f2a4d6e8c0b2d4e6f8a0c2e4d6f8a0b2c4d6e8f0a2`

```bash
# Test with curl
curl -X POST http://localhost:3000/webhook \
  -H "Content-Type: application/json" \
  -H "X-Panoptes-Signature: d3a5e8c7b2f9a1d4e6c8b0f2a4d6e8c0b2d4e6f8a0c2e4d6f8a0b2c4d6e8f0a2" \
  -d '{"event":"test","data":{"value":123}}'
```

You can also generate signatures manually:

```bash
# Using openssl
echo -n '{"event":"test","data":{"value":123}}' | \
  openssl dgst -sha256 -hmac "test-secret-key" | \
  awk '{print $2}'
```

---

## üîí Security Best Practices

### 1. Use Constant-Time Comparison

**Why**: Prevents timing attacks where attackers measure response times to guess signatures.

```javascript
// ‚ùå NEVER DO THIS - Vulnerable to timing attacks
if (signature === computedSignature) { ... }

// ‚úÖ Always use constant-time comparison
if (crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(computedSignature))) { ... }
```

**Available in**:
- Node.js: `crypto.timingSafeEqual()`
- Python: `hmac.compare_digest()`
- C#: `CryptographicOperations.FixedTimeEquals()`
- Go: `subtle.ConstantTimeCompare()`
- PHP: `hash_equals()`
- Ruby: `Rack::Utils.secure_compare()`
- Java: `MessageDigest.isEqual()`

### 2. Protect Your Secret Keys

**Storage**:
```bash
# ‚úÖ Use environment variables
export PANOPTES_SECRET_KEY="your-secret-key-here"

# ‚úÖ Use secret management services
# - AWS Secrets Manager
# - Azure Key Vault
# - HashiCorp Vault
# - Google Secret Manager
```

**Never**:
- ‚ùå Hardcode secrets in source code
- ‚ùå Commit secrets to version control
- ‚ùå Log secrets in application logs
- ‚ùå Send secrets in error messages
- ‚ùå Store secrets in client-side code

### 3. Use HTTPS Only

Always use HTTPS for webhook URLs:
```
‚úÖ https://your-domain.com/webhook
‚ùå http://your-domain.com/webhook
```

HTTP connections expose both payloads and signatures to eavesdropping.

### 4. Implement Additional Security Layers

While signature verification is essential, combine it with:

1. **IP Whitelisting**: Restrict webhook sources
2. **Rate Limiting**: Prevent abuse
3. **Request Logging**: Track suspicious patterns
4. **Idempotency**: Handle duplicate deliveries
5. **Timestamp Validation**: Reject old webhooks (if timestamp included)

### 5. Handle Secrets Securely in Code

```javascript
// ‚úÖ Load once at startup
const SECRET = process.env.PANOPTES_SECRET_KEY;

// ‚úÖ Clear from memory when done (if possible)
// ‚úÖ Don't log or expose in errors
try {
  verifySignature(secret);
} catch (err) {
  console.error('Verification failed'); // Don't log secret!
}
```

### 6. Rotate Secrets Regularly

Implement a secret rotation strategy:
1. Generate new secret in Panoptes
2. Update your application configuration
3. Keep old secret valid for 24-48 hours (grace period)
4. Accept both old and new signatures during transition
5. Remove old secret after grace period

### 7. Monitor and Alert

Set up monitoring for:
- Failed signature verifications (possible attack)
- Missing signatures (misconfiguration)
- Unusual webhook volumes
- Repeated failures from same source

---

## üìö Additional Resources

- [HMAC Wikipedia](https://en.wikipedia.org/wiki/HMAC)
- [OWASP: Webhook Security](https://cheatsheetseries.owasp.org/cheatsheets/Webhook_Security_Cheat_Sheet.html)
- [RFC 2104: HMAC Specification](https://tools.ietf.org/html/rfc2104)

---

## ‚ùì FAQ

### Q: Can I use a different hashing algorithm?
**A**: No. Panoptes uses HMAC-SHA256 specifically. You must use SHA256 for compatibility.

### Q: How long are the signatures?
**A**: HMAC-SHA256 produces 64 hexadecimal characters (256 bits / 8 bits per byte √ó 2 chars per byte).

### Q: Should signatures be uppercase or lowercase?
**A**: Panoptes sends lowercase signatures. Your comparison should be case-insensitive or convert both to lowercase.

### Q: What if the signature header is missing?
**A**: Reject the request with 401 Unauthorized. All legitimate webhooks include signatures.

### Q: Do I need to verify signatures in development?
**A**: Yes! Always verify signatures, even in development, to catch integration issues early.

### Q: Can I cache the computed signature?
**A**: No. Each webhook has a unique payload, so each requires a fresh signature computation.

### Q: What about replay attacks?
**A**: Signature verification alone doesn't prevent replays. Implement idempotency keys or timestamp validation for replay protection.

---

## üìû Support

If you encounter issues with webhook signature verification:

1. Review the troubleshooting section above
2. Test with the provided example payloads
3. Check your secret key in the Panoptes dashboard
4. Open an issue on [GitHub](https://github.com/gauciv/panoptes/issues)

---

**Last Updated**: December 2025  
**Panoptes Version**: 2.0+
